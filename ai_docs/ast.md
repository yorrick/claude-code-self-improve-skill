Title: ast — Abstract syntax trees

URL Source: https://docs.python.org/3/library/ast.html

Published Time: Thu, 22 Jan 2026 15:58:32 GMT

Markdown Content:
ast — Abstract syntax trees — Python 3.14.2 documentation
===============

- [x] [![Image 1: Python logo](https://docs.python.org/3/_static/py.svg)](https://www.python.org/)

 Theme  

### [Table of Contents](https://docs.python.org/3/contents.html)

*   [`ast` — Abstract syntax trees](https://docs.python.org/3/library/ast.html#)
    *   [Abstract grammar](https://docs.python.org/3/library/ast.html#abstract-grammar)
    *   [Node classes](https://docs.python.org/3/library/ast.html#node-classes)
        *   [Root nodes](https://docs.python.org/3/library/ast.html#root-nodes)
        *   [Literals](https://docs.python.org/3/library/ast.html#literals)
        *   [Variables](https://docs.python.org/3/library/ast.html#variables)
        *   [Expressions](https://docs.python.org/3/library/ast.html#expressions)
            *   [Subscripting](https://docs.python.org/3/library/ast.html#subscripting)
            *   [Comprehensions](https://docs.python.org/3/library/ast.html#comprehensions)

        *   [Statements](https://docs.python.org/3/library/ast.html#statements)
            *   [Imports](https://docs.python.org/3/library/ast.html#imports)

        *   [Control flow](https://docs.python.org/3/library/ast.html#control-flow)
        *   [Pattern matching](https://docs.python.org/3/library/ast.html#pattern-matching)
        *   [Type annotations](https://docs.python.org/3/library/ast.html#type-annotations)
        *   [Type parameters](https://docs.python.org/3/library/ast.html#type-parameters)
        *   [Function and class definitions](https://docs.python.org/3/library/ast.html#function-and-class-definitions)
        *   [Async and await](https://docs.python.org/3/library/ast.html#async-and-await)

    *   [`ast` helpers](https://docs.python.org/3/library/ast.html#ast-helpers)
    *   [Compiler flags](https://docs.python.org/3/library/ast.html#compiler-flags)
    *   [Command-line usage](https://docs.python.org/3/library/ast.html#command-line-usage)

#### Previous topic

[Python Language Services](https://docs.python.org/3/library/language.html "previous chapter")

#### Next topic

[`symtable` — Access to the compiler’s symbol tables](https://docs.python.org/3/library/symtable.html "next chapter")

### This page

*   [Report a bug](https://docs.python.org/3/bugs.html)
*   [Show source](https://github.com/python/cpython/blob/main/Doc/library/ast.rst?plain=1)

### Navigation

*   [index](https://docs.python.org/3/genindex.html "General Index")
*   [modules](https://docs.python.org/3/py-modindex.html "Python Module Index") |
*   [next](https://docs.python.org/3/library/symtable.html "symtable — Access to the compiler’s symbol tables") |
*   [previous](https://docs.python.org/3/library/language.html "Python Language Services") |
*   ![Image 2: Python logo](https://docs.python.org/3/_static/py.svg)
*   [Python](https://www.python.org/) »
*     

*   [3.14.2 Documentation](https://docs.python.org/3/index.html) » 
*   [The Python Standard Library](https://docs.python.org/3/library/index.html) »
*   [Python Language Services](https://docs.python.org/3/library/language.html) »
*   [`ast` — Abstract syntax trees](https://docs.python.org/3/library/ast.html)
*     | 
*    Theme   |

`ast` — Abstract syntax trees[¶](https://docs.python.org/3/library/ast.html#module-ast "Link to this heading")
==============================================================================================================

**Source code:**[Lib/ast.py](https://github.com/python/cpython/tree/3.14/Lib/ast.py)

* * *

The [`ast`](https://docs.python.org/3/library/ast.html#module-ast "ast: Abstract Syntax Tree classes and manipulation.") module helps Python applications to process trees of the Python abstract syntax grammar. The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like.

An abstract syntax tree can be generated by passing [`ast.PyCF_ONLY_AST`](https://docs.python.org/3/library/ast.html#ast.PyCF_ONLY_AST "ast.PyCF_ONLY_AST") as a flag to the [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile") built-in function, or using the [`parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") helper provided in this module. The result will be a tree of objects whose classes all inherit from [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST"). An abstract syntax tree can be compiled into a Python code object using the built-in [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile") function.

Abstract grammar[¶](https://docs.python.org/3/library/ast.html#abstract-grammar "Link to this heading")
-------------------------------------------------------------------------------------------------------

The abstract grammar is currently defined as follows:

-- ASDL's 4 builtin types are:
-- identifier, int, string, constant

module Python
{
    mod = Module(stmt* body, type_ignore* type_ignores)
        | Interactive(stmt* body)
        | Expression(expr body)
        | FunctionType(expr* argtypes, expr returns)

    stmt = FunctionDef(identifier name, arguments args,
                       stmt* body, expr* decorator_list, expr? returns,
                       string? type_comment, type_param* type_params)
          | AsyncFunctionDef(identifier name, arguments args,
                             stmt* body, expr* decorator_list, expr? returns,
                             string? type_comment, type_param* type_params)

          | ClassDef(identifier name,
             expr* bases,
             keyword* keywords,
             stmt* body,
             expr* decorator_list,
             type_param* type_params)
          | Return(expr? value)

          | Delete(expr* targets)
          | Assign(expr* targets, expr value, string? type_comment)
          | TypeAlias(expr name, type_param* type_params, expr value)
          | AugAssign(expr target, operator op, expr value)
          -- 'simple' indicates that we annotate simple name without parens
          | AnnAssign(expr target, expr annotation, expr? value, int simple)

          -- use 'orelse' because else is a keyword in target languages
          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | While(expr test, stmt* body, stmt* orelse)
          | If(expr test, stmt* body, stmt* orelse)
          | With(withitem* items, stmt* body, string? type_comment)
          | AsyncWith(withitem* items, stmt* body, string? type_comment)

          | Match(expr subject, match_case* cases)

          | Raise(expr? exc, expr? cause)
          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
          | Assert(expr test, expr? msg)

          | Import(alias* names)
          | ImportFrom(identifier? module, alias* names, int? level)

          | Global(identifier* names)
          | Nonlocal(identifier* names)
          | Expr(expr value)
          | Pass | Break | Continue

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

          -- BoolOp() can use left & right?
    expr = BoolOp(boolop op, expr* values)
         | NamedExpr(expr target, expr value)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr?* keys, expr* values)
         | Set(expr* elts)
         | ListComp(expr elt, comprehension* generators)
         | SetComp(expr elt, comprehension* generators)
         | DictComp(expr key, expr value, comprehension* generators)
         | GeneratorExp(expr elt, comprehension* generators)
         -- the grammar constrains where yield expressions can occur
         | Await(expr value)
         | Yield(expr? value)
         | YieldFrom(expr value)
         -- need sequences for compare to distinguish between
         -- x < 4 < 3 and (x < 4) < 3
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args, keyword* keywords)
         | FormattedValue(expr value, int conversion, expr? format_spec)
         | Interpolation(expr value, constant str, int conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | TemplateStr(expr* values)
         | Constant(constant value, string? kind)

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier attr, expr_context ctx)
         | Subscript(expr value, expr slice, expr_context ctx)
         | Starred(expr value, expr_context ctx)
         | Name(identifier id, expr_context ctx)
         | List(expr* elts, expr_context ctx)
         | Tuple(expr* elts, expr_context ctx)

         -- can appear only in Subscript
         | Slice(expr? lower, expr? upper, expr? step)

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    expr_context = Load | Store | Del

    boolop = And | Or

    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

    unaryop = Invert | Not | UAdd | USub

    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    comprehension = (expr target, expr iter, expr* ifs, int is_async)

    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                    attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
                 expr?* kw_defaults, arg? kwarg, expr* defaults)

    arg = (identifier arg, expr? annotation, string? type_comment)
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    -- keyword arguments supplied to call (NULL identifier for **kwargs)
    keyword = (identifier? arg, expr value)
               attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    -- import name with optional 'as' alias.
    alias = (identifier name, identifier? asname)
             attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    withitem = (expr context_expr, expr? optional_vars)

    match_case = (pattern pattern, expr? guard, stmt* body)

    pattern = MatchValue(expr value)
            | MatchSingleton(constant value)
            | MatchSequence(pattern* patterns)
            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)
            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)

            | MatchStar(identifier? name)
            -- The optional "rest" MatchMapping parameter handles capturing extra mapping keys

            | MatchAs(pattern? pattern, identifier? name)
            | MatchOr(pattern* patterns)

             attributes (int lineno, int col_offset, int end_lineno, int end_col_offset)

    type_ignore = TypeIgnore(int lineno, string tag)

    type_param = TypeVar(identifier name, expr? bound, expr? default_value)
               | ParamSpec(identifier name, expr? default_value)
               | TypeVarTuple(identifier name, expr? default_value)
               attributes (int lineno, int col_offset, int end_lineno, int end_col_offset)
}

Node classes[¶](https://docs.python.org/3/library/ast.html#node-classes "Link to this heading")
-----------------------------------------------------------------------------------------------

_class_ ast.AST[¶](https://docs.python.org/3/library/ast.html#ast.AST "Link to this definition")
This is the base of all AST node classes. The actual node classes are derived from the `Parser/Python.asdl` file, which is reproduced [above](https://docs.python.org/3/library/ast.html#abstract-grammar). They are defined in the `_ast` C module and re-exported in [`ast`](https://docs.python.org/3/library/ast.html#module-ast "ast: Abstract Syntax Tree classes and manipulation.").

There is one class defined for each left-hand side symbol in the abstract grammar (for example, `ast.stmt` or `ast.expr`). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, [`ast.BinOp`](https://docs.python.org/3/library/ast.html#ast.BinOp "ast.BinOp") inherits from `ast.expr`. For production rules with alternatives (aka “sums”), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.

_fields[¶](https://docs.python.org/3/library/ast.html#ast.AST._fields "Link to this definition")
Each concrete class has an attribute `_fields` which gives the names of all child nodes.

Each instance of a concrete class has one attribute for each child node, of the type as defined in the grammar. For example, [`ast.BinOp`](https://docs.python.org/3/library/ast.html#ast.BinOp "ast.BinOp") instances have an attribute `left` of type `ast.expr`.

If these attributes are marked as optional in the grammar (using a question mark), the value might be `None`. If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists. All possible attributes must be present and have valid values when compiling an AST with [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile").

_field_types[¶](https://docs.python.org/3/library/ast.html#ast.AST._field_types "Link to this definition")
The `_field_types` attribute on each concrete class is a dictionary mapping field names (as also listed in [`_fields`](https://docs.python.org/3/library/ast.html#ast.AST._fields "ast.AST._fields")) to their types.

>>> ast.TypeVar._field_types
{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr | None}

Added in version 3.13.

lineno[¶](https://docs.python.org/3/library/ast.html#ast.AST.lineno "Link to this definition")col_offset[¶](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "Link to this definition")end_lineno[¶](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "Link to this definition")end_col_offset[¶](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "Link to this definition")
Instances of `ast.expr` and `ast.stmt` subclasses have [`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno"), [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset"), [`end_lineno`](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "ast.AST.end_lineno"), and [`end_col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "ast.AST.end_col_offset") attributes. The [`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno") and [`end_lineno`](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "ast.AST.end_lineno") are the first and last line numbers of source text span (1-indexed so the first line is line 1) and the [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset") and [`end_col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "ast.AST.end_col_offset") are the corresponding UTF-8 byte offsets of the first and last tokens that generated the node. The UTF-8 offset is recorded because the parser uses UTF-8 internally.

Note that the end positions are not required by the compiler and are therefore optional. The end offset is _after_ the last symbol, for example one can get the source segment of a one-line expression node using `source_line[node.col_offset : node.end_col_offset]`.

The constructor of a class `ast.T` parses its arguments as follows:

*   If there are positional arguments, there must be as many as there are items in `T._fields`; they will be assigned as attributes of these names.

*   If there are keyword arguments, they will set the attributes of the same names to the given values.

For example, to create and populate an [`ast.UnaryOp`](https://docs.python.org/3/library/ast.html#ast.UnaryOp "ast.UnaryOp") node, you could use

node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),
                   lineno=0, col_offset=0)

If a field that is optional in the grammar is omitted from the constructor, it defaults to `None`. If a list field is omitted, it defaults to the empty list. If a field of type `ast.expr_context` is omitted, it defaults to [`Load()`](https://docs.python.org/3/library/ast.html#ast.Load "ast.Load"). If any other field is omitted, a [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning "DeprecationWarning") is raised and the AST node will not have this field. In Python 3.15, this condition will raise an error.

Changed in version 3.8: Class [`ast.Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant") is now used for all constants.

Changed in version 3.9: Simple indices are represented by their value, extended slices are represented as tuples.

Changed in version 3.14: The [`__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__ "object.__repr__") output of [`AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") nodes includes the values of the node fields.

Deprecated since version 3.8, removed in version 3.14: Previous versions of Python provided the AST classes `ast.Num`, `ast.Str`, `ast.Bytes`, `ast.NameConstant` and `ast.Ellipsis`, which were deprecated in Python 3.8. These classes were removed in Python 3.14, and their functionality has been replaced with [`ast.Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant").

Deprecated since version 3.9: Old classes `ast.Index` and `ast.ExtSlice` are still available, but they will be removed in future Python releases. In the meantime, instantiating them will return an instance of a different class.

Deprecated since version 3.13, will be removed in version 3.15: Previous versions of Python allowed the creation of AST nodes that were missing required fields. Similarly, AST node constructors allowed arbitrary keyword arguments that were set as attributes of the AST node, even if they did not match any of the fields of the AST node. This behavior is deprecated and will be removed in Python 3.15.

Note

The descriptions of the specific node classes displayed here were initially adapted from the fantastic [Green Tree Snakes](https://greentreesnakes.readthedocs.io/en/latest/) project and all its contributors.

### Root nodes[¶](https://docs.python.org/3/library/ast.html#root-nodes "Link to this heading")

_class_ ast.Module(_body_, _type\_ignores_)[¶](https://docs.python.org/3/library/ast.html#ast.Module "Link to this definition")
A Python module, as with [file input](https://docs.python.org/3/reference/toplevel_components.html#file-input). Node type generated by [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") in the default `"exec"`_mode_.

`body` is a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") of the module’s [Statements](https://docs.python.org/3/library/ast.html#ast-statements).

`type_ignores` is a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") of the module’s type ignore comments; see [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") for more details.

>>> print(ast.dump(ast.parse('x = 1'), indent=4))
Module(
 body=[
 Assign(
 targets=[
 Name(id='x', ctx=Store())],
 value=Constant(value=1))])

_class_ ast.Expression(_body_)[¶](https://docs.python.org/3/library/ast.html#ast.Expression "Link to this definition")
A single Python [expression input](https://docs.python.org/3/reference/toplevel_components.html#expression-input). Node type generated by [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") when _mode_ is `"eval"`.

`body` is a single node, one of the [expression types](https://docs.python.org/3/library/ast.html#ast-expressions).

>>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))
Expression(
 body=Constant(value=123))

_class_ ast.Interactive(_body_)[¶](https://docs.python.org/3/library/ast.html#ast.Interactive "Link to this definition")
A single [interactive input](https://docs.python.org/3/reference/toplevel_components.html#interactive), like in [Interactive Mode](https://docs.python.org/3/tutorial/appendix.html#tut-interac). Node type generated by [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") when _mode_ is `"single"`.

`body` is a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") of [statement nodes](https://docs.python.org/3/library/ast.html#ast-statements).

>>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))
Interactive(
 body=[
 Assign(
 targets=[
 Name(id='x', ctx=Store())],
 value=Constant(value=1)),
 Assign(
 targets=[
 Name(id='y', ctx=Store())],
 value=Constant(value=2))])

_class_ ast.FunctionType(_argtypes_, _returns_)[¶](https://docs.python.org/3/library/ast.html#ast.FunctionType "Link to this definition")
A representation of an old-style type comments for functions, as Python versions prior to 3.5 didn’t support [**PEP 484**](https://peps.python.org/pep-0484/) annotations. Node type generated by [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") when _mode_ is `"func_type"`.

Such type comments would look like this:

def sum_two_number(a, b):
    # type: (int, int) -> int
    return a + b

`argtypes` is a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") of [expression nodes](https://docs.python.org/3/library/ast.html#ast-expressions).

`returns` is a single [expression node](https://docs.python.org/3/library/ast.html#ast-expressions).

>>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), indent=4))
FunctionType(
 argtypes=[
 Name(id='int', ctx=Load()),
 Name(id='str', ctx=Load())],
 returns=Subscript(
 value=Name(id='List', ctx=Load()),
 slice=Name(id='int', ctx=Load()),
 ctx=Load()))

Added in version 3.8.

### Literals[¶](https://docs.python.org/3/library/ast.html#literals "Link to this heading")

_class_ ast.Constant(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.Constant "Link to this definition")
A constant value. The `value` attribute of the `Constant` literal contains the Python object it represents. The values represented can be instances of [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes"), [`int`](https://docs.python.org/3/library/functions.html#int "int"), [`float`](https://docs.python.org/3/library/functions.html#float "float"), [`complex`](https://docs.python.org/3/library/functions.html#complex "complex"), and [`bool`](https://docs.python.org/3/library/functions.html#bool "bool"), and the constants [`None`](https://docs.python.org/3/library/constants.html#None "None") and [`Ellipsis`](https://docs.python.org/3/library/constants.html#Ellipsis "Ellipsis").

>>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))
Expression(
 body=Constant(value=123))

_class_ ast.FormattedValue(_value_, _conversion_, _format\_spec_)[¶](https://docs.python.org/3/library/ast.html#ast.FormattedValue "Link to this definition")
Node representing a single formatting field in an f-string. If the string contains a single formatting field and nothing else the node can be isolated otherwise it appears in [`JoinedStr`](https://docs.python.org/3/library/ast.html#ast.JoinedStr "ast.JoinedStr").

*   `value` is any expression node (such as a literal, a variable, or a function call).

*   `conversion` is an integer:

    *   -1: no formatting

    *   97 (`ord('a')`): `!a`[`ASCII`](https://docs.python.org/3/library/functions.html#ascii "ascii") formatting

    *   114 (`ord('r')`): `!r`[`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") formatting

    *   115 (`ord('s')`): `!s`[`string`](https://docs.python.org/3/library/stdtypes.html#str "str") formatting

*   `format_spec` is a [`JoinedStr`](https://docs.python.org/3/library/ast.html#ast.JoinedStr "ast.JoinedStr") node representing the formatting of the value, or `None` if no format was specified. Both `conversion` and `format_spec` can be set at the same time.

_class_ ast.JoinedStr(_values_)[¶](https://docs.python.org/3/library/ast.html#ast.JoinedStr "Link to this definition")
An f-string, comprising a series of [`FormattedValue`](https://docs.python.org/3/library/ast.html#ast.FormattedValue "ast.FormattedValue") and [`Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant") nodes.

>>> print(ast.dump(ast.parse('f"sin({a}) is {sin(a):.3}"', mode='eval'), indent=4))
Expression(
 body=JoinedStr(
 values=[
 Constant(value='sin('),
 FormattedValue(
 value=Name(id='a', ctx=Load()),
 conversion=-1),
 Constant(value=') is '),
 FormattedValue(
 value=Call(
 func=Name(id='sin', ctx=Load()),
 args=[
 Name(id='a', ctx=Load())]),
 conversion=-1,
 format_spec=JoinedStr(
 values=[
 Constant(value='.3')]))]))

_class_ ast.TemplateStr(_values_, _/_)[¶](https://docs.python.org/3/library/ast.html#ast.TemplateStr "Link to this definition")

Added in version 3.14.

Node representing a template string literal, comprising a series of [`Interpolation`](https://docs.python.org/3/library/ast.html#ast.Interpolation "ast.Interpolation") and [`Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant") nodes. These nodes may be any order, and do not need to be interleaved.

>>> expr = ast.parse('t"{name} finished {place:ordinal}"', mode='eval')
>>> print(ast.dump(expr, indent=4))
Expression(
 body=TemplateStr(
 values=[
 Interpolation(
 value=Name(id='name', ctx=Load()),
 str='name',
 conversion=-1),
 Constant(value=' finished '),
 Interpolation(
 value=Name(id='place', ctx=Load()),
 str='place',
 conversion=-1,
 format_spec=JoinedStr(
 values=[
 Constant(value='ordinal')]))]))

_class_ ast.Interpolation(_value_, _str_, _conversion_, _format\_spec=None_)[¶](https://docs.python.org/3/library/ast.html#ast.Interpolation "Link to this definition")

Added in version 3.14.

Node representing a single interpolation field in a template string literal.

*   `value` is any expression node (such as a literal, a variable, or a function call). This has the same meaning as `FormattedValue.value`.

*   `str` is a constant containing the text of the interpolation expression.

If `str` is set to `None`, then `value` is used to generate code when calling [`ast.unparse()`](https://docs.python.org/3/library/ast.html#ast.unparse "ast.unparse"). This no longer guarantees that the generated code is identical to the original and is intended for code generation.

*   `conversion` is an integer:

    *   -1: no conversion

    *   97 (`ord('a')`): `!a`[`ASCII`](https://docs.python.org/3/library/functions.html#ascii "ascii") conversion

    *   114 (`ord('r')`): `!r`[`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") conversion

    *   115 (`ord('s')`): `!s`[`string`](https://docs.python.org/3/library/stdtypes.html#str "str") conversion

This has the same meaning as `FormattedValue.conversion`.

*   `format_spec` is a [`JoinedStr`](https://docs.python.org/3/library/ast.html#ast.JoinedStr "ast.JoinedStr") node representing the formatting of the value, or `None` if no format was specified. Both `conversion` and `format_spec` can be set at the same time. This has the same meaning as `FormattedValue.format_spec`.

_class_ ast.List(_elts_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.List "Link to this definition")_class_ ast.Tuple(_elts_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.Tuple "Link to this definition")
A list or tuple. `elts` holds a list of nodes representing the elements. `ctx` is [`Store`](https://docs.python.org/3/library/ast.html#ast.Store "ast.Store") if the container is an assignment target (i.e. `(x,y)=something`), and [`Load`](https://docs.python.org/3/library/ast.html#ast.Load "ast.Load") otherwise.

>>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))
Expression(
 body=List(
 elts=[
 Constant(value=1),
 Constant(value=2),
 Constant(value=3)],
 ctx=Load()))
>>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))
Expression(
 body=Tuple(
 elts=[
 Constant(value=1),
 Constant(value=2),
 Constant(value=3)],
 ctx=Load()))

_class_ ast.Set(_elts_)[¶](https://docs.python.org/3/library/ast.html#ast.Set "Link to this definition")
A set. `elts` holds a list of nodes representing the set’s elements.

>>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))
Expression(
 body=Set(
 elts=[
 Constant(value=1),
 Constant(value=2),
 Constant(value=3)]))

_class_ ast.Dict(_keys_, _values_)[¶](https://docs.python.org/3/library/ast.html#ast.Dict "Link to this definition")
A dictionary. `keys` and `values` hold lists of nodes representing the keys and the values respectively, in matching order (what would be returned when calling `dictionary.keys()` and `dictionary.values()`).

When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the `values` list, with a `None` at the corresponding position in `keys`.

>>> print(ast.dump(ast.parse('{"a":1, **d}', mode='eval'), indent=4))
Expression(
 body=Dict(
 keys=[
 Constant(value='a'),
 None],
 values=[
 Constant(value=1),
 Name(id='d', ctx=Load())]))

### Variables[¶](https://docs.python.org/3/library/ast.html#variables "Link to this heading")

_class_ ast.Name(_id_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.Name "Link to this definition")
A variable name. `id` holds the name as a string, and `ctx` is one of the following types.

_class_ ast.Load[¶](https://docs.python.org/3/library/ast.html#ast.Load "Link to this definition")_class_ ast.Store[¶](https://docs.python.org/3/library/ast.html#ast.Store "Link to this definition")_class_ ast.Del[¶](https://docs.python.org/3/library/ast.html#ast.Del "Link to this definition")
Variable references can be used to load the value of a variable, to assign a new value to it, or to delete it. Variable references are given a context to distinguish these cases.

>>> print(ast.dump(ast.parse('a'), indent=4))
Module(
 body=[
 Expr(
 value=Name(id='a', ctx=Load()))])

>>> print(ast.dump(ast.parse('a = 1'), indent=4))
Module(
 body=[
 Assign(
 targets=[
 Name(id='a', ctx=Store())],
 value=Constant(value=1))])

>>> print(ast.dump(ast.parse('del a'), indent=4))
Module(
 body=[
 Delete(
 targets=[
 Name(id='a', ctx=Del())])])

_class_ ast.Starred(_value_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.Starred "Link to this definition")
A `*var` variable reference. `value` holds the variable, typically a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node. This type must be used when building a [`Call`](https://docs.python.org/3/library/ast.html#ast.Call "ast.Call") node with `*args`.

>>> print(ast.dump(ast.parse('a, *b = it'), indent=4))
Module(
 body=[
 Assign(
 targets=[
 Tuple(
 elts=[
 Name(id='a', ctx=Store()),
 Starred(
 value=Name(id='b', ctx=Store()),
 ctx=Store())],
 ctx=Store())],
 value=Name(id='it', ctx=Load()))])

### Expressions[¶](https://docs.python.org/3/library/ast.html#expressions "Link to this heading")

_class_ ast.Expr(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.Expr "Link to this definition")
When an expression, such as a function call, appears as a statement by itself with its return value not used or stored, it is wrapped in this container. `value` holds one of the other nodes in this section, a [`Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant"), a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), a [`Lambda`](https://docs.python.org/3/library/ast.html#ast.Lambda "ast.Lambda"), a [`Yield`](https://docs.python.org/3/library/ast.html#ast.Yield "ast.Yield") or [`YieldFrom`](https://docs.python.org/3/library/ast.html#ast.YieldFrom "ast.YieldFrom") node.

>>> print(ast.dump(ast.parse('-a'), indent=4))
Module(
 body=[
 Expr(
 value=UnaryOp(
 op=USub(),
 operand=Name(id='a', ctx=Load())))])

_class_ ast.UnaryOp(_op_, _operand_)[¶](https://docs.python.org/3/library/ast.html#ast.UnaryOp "Link to this definition")
A unary operation. `op` is the operator, and `operand` any expression node.

_class_ ast.UAdd[¶](https://docs.python.org/3/library/ast.html#ast.UAdd "Link to this definition")_class_ ast.USub[¶](https://docs.python.org/3/library/ast.html#ast.USub "Link to this definition")_class_ ast.Not[¶](https://docs.python.org/3/library/ast.html#ast.Not "Link to this definition")_class_ ast.Invert[¶](https://docs.python.org/3/library/ast.html#ast.Invert "Link to this definition")
Unary operator tokens. [`Not`](https://docs.python.org/3/library/ast.html#ast.Not "ast.Not") is the `not` keyword, [`Invert`](https://docs.python.org/3/library/ast.html#ast.Invert "ast.Invert") is the `~` operator.

>>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))
Expression(
 body=UnaryOp(
 op=Not(),
 operand=Name(id='x', ctx=Load())))

_class_ ast.BinOp(_left_, _op_, _right_)[¶](https://docs.python.org/3/library/ast.html#ast.BinOp "Link to this definition")
A binary operation (like addition or division). `op` is the operator, and `left` and `right` are any expression nodes.

>>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))
Expression(
 body=BinOp(
 left=Name(id='x', ctx=Load()),
 op=Add(),
 right=Name(id='y', ctx=Load())))

_class_ ast.Add[¶](https://docs.python.org/3/library/ast.html#ast.Add "Link to this definition")_class_ ast.Sub[¶](https://docs.python.org/3/library/ast.html#ast.Sub "Link to this definition")_class_ ast.Mult[¶](https://docs.python.org/3/library/ast.html#ast.Mult "Link to this definition")_class_ ast.Div[¶](https://docs.python.org/3/library/ast.html#ast.Div "Link to this definition")_class_ ast.FloorDiv[¶](https://docs.python.org/3/library/ast.html#ast.FloorDiv "Link to this definition")_class_ ast.Mod[¶](https://docs.python.org/3/library/ast.html#ast.Mod "Link to this definition")_class_ ast.Pow[¶](https://docs.python.org/3/library/ast.html#ast.Pow "Link to this definition")_class_ ast.LShift[¶](https://docs.python.org/3/library/ast.html#ast.LShift "Link to this definition")_class_ ast.RShift[¶](https://docs.python.org/3/library/ast.html#ast.RShift "Link to this definition")_class_ ast.BitOr[¶](https://docs.python.org/3/library/ast.html#ast.BitOr "Link to this definition")_class_ ast.BitXor[¶](https://docs.python.org/3/library/ast.html#ast.BitXor "Link to this definition")_class_ ast.BitAnd[¶](https://docs.python.org/3/library/ast.html#ast.BitAnd "Link to this definition")_class_ ast.MatMult[¶](https://docs.python.org/3/library/ast.html#ast.MatMult "Link to this definition")
Binary operator tokens.

_class_ ast.BoolOp(_op_, _values_)[¶](https://docs.python.org/3/library/ast.html#ast.BoolOp "Link to this definition")
A boolean operation, ‘or’ or ‘and’. `op` is [`Or`](https://docs.python.org/3/library/ast.html#ast.Or "ast.Or") or [`And`](https://docs.python.org/3/library/ast.html#ast.And "ast.And"). `values` are the values involved. Consecutive operations with the same operator, such as `a or b or c`, are collapsed into one node with several values.

This doesn’t include `not`, which is a [`UnaryOp`](https://docs.python.org/3/library/ast.html#ast.UnaryOp "ast.UnaryOp").

>>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))
Expression(
 body=BoolOp(
 op=Or(),
 values=[
 Name(id='x', ctx=Load()),
 Name(id='y', ctx=Load())]))

_class_ ast.And[¶](https://docs.python.org/3/library/ast.html#ast.And "Link to this definition")_class_ ast.Or[¶](https://docs.python.org/3/library/ast.html#ast.Or "Link to this definition")
Boolean operator tokens.

_class_ ast.Compare(_left_, _ops_, _comparators_)[¶](https://docs.python.org/3/library/ast.html#ast.Compare "Link to this definition")
A comparison of two or more values. `left` is the first value in the comparison, `ops` the list of operators, and `comparators` the list of values after the first element in the comparison.

>>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))
Expression(
 body=Compare(
 left=Constant(value=1),
 ops=[
 LtE(),
 Lt()],
 comparators=[
 Name(id='a', ctx=Load()),
 Constant(value=10)]))

_class_ ast.Eq[¶](https://docs.python.org/3/library/ast.html#ast.Eq "Link to this definition")_class_ ast.NotEq[¶](https://docs.python.org/3/library/ast.html#ast.NotEq "Link to this definition")_class_ ast.Lt[¶](https://docs.python.org/3/library/ast.html#ast.Lt "Link to this definition")_class_ ast.LtE[¶](https://docs.python.org/3/library/ast.html#ast.LtE "Link to this definition")_class_ ast.Gt[¶](https://docs.python.org/3/library/ast.html#ast.Gt "Link to this definition")_class_ ast.GtE[¶](https://docs.python.org/3/library/ast.html#ast.GtE "Link to this definition")_class_ ast.Is[¶](https://docs.python.org/3/library/ast.html#ast.Is "Link to this definition")_class_ ast.IsNot[¶](https://docs.python.org/3/library/ast.html#ast.IsNot "Link to this definition")_class_ ast.In[¶](https://docs.python.org/3/library/ast.html#ast.In "Link to this definition")_class_ ast.NotIn[¶](https://docs.python.org/3/library/ast.html#ast.NotIn "Link to this definition")
Comparison operator tokens.

_class_ ast.Call(_func_, _args_, _keywords_)[¶](https://docs.python.org/3/library/ast.html#ast.Call "Link to this definition")
A function call. `func` is the function, which will often be a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") or [`Attribute`](https://docs.python.org/3/library/ast.html#ast.Attribute "ast.Attribute") object. Of the arguments:

*   `args` holds a list of the arguments passed by position.

*   `keywords` holds a list of [`keyword`](https://docs.python.org/3/library/ast.html#ast.keyword "ast.keyword") objects representing arguments passed by keyword.

The `args` and `keywords` arguments are optional and default to empty lists.

>>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), indent=4))
Expression(
 body=Call(
 func=Name(id='func', ctx=Load()),
 args=[
 Name(id='a', ctx=Load()),
 Starred(
 value=Name(id='d', ctx=Load()),
 ctx=Load())],
 keywords=[
 keyword(
 arg='b',
 value=Name(id='c', ctx=Load())),
 keyword(
 value=Name(id='e', ctx=Load()))]))

_class_ ast.keyword(_arg_, _value_)[¶](https://docs.python.org/3/library/ast.html#ast.keyword "Link to this definition")
A keyword argument to a function call or class definition. `arg` is a raw string of the parameter name, `value` is a node to pass in.

_class_ ast.IfExp(_test_, _body_, _orelse_)[¶](https://docs.python.org/3/library/ast.html#ast.IfExp "Link to this definition")
An expression such as `a if b else c`. Each field holds a single node, so in the following example, all three are [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") nodes.

>>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))
Expression(
 body=IfExp(
 test=Name(id='b', ctx=Load()),
 body=Name(id='a', ctx=Load()),
 orelse=Name(id='c', ctx=Load())))

_class_ ast.Attribute(_value_, _attr_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.Attribute "Link to this definition")
Attribute access, e.g. `d.keys`. `value` is a node, typically a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"). `attr` is a bare string giving the name of the attribute, and `ctx` is [`Load`](https://docs.python.org/3/library/ast.html#ast.Load "ast.Load"), [`Store`](https://docs.python.org/3/library/ast.html#ast.Store "ast.Store") or [`Del`](https://docs.python.org/3/library/ast.html#ast.Del "ast.Del") according to how the attribute is acted on.

>>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))
Expression(
 body=Attribute(
 value=Name(id='snake', ctx=Load()),
 attr='colour',
 ctx=Load()))

_class_ ast.NamedExpr(_target_, _value_)[¶](https://docs.python.org/3/library/ast.html#ast.NamedExpr "Link to this definition")
A named expression. This AST node is produced by the assignment expressions operator (also known as the walrus operator). As opposed to the [`Assign`](https://docs.python.org/3/library/ast.html#ast.Assign "ast.Assign") node in which the first argument can be multiple nodes, in this case both `target` and `value` must be single nodes.

>>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))
Expression(
 body=NamedExpr(
 target=Name(id='x', ctx=Store()),
 value=Constant(value=4)))

Added in version 3.8.

#### Subscripting[¶](https://docs.python.org/3/library/ast.html#subscripting "Link to this heading")

_class_ ast.Subscript(_value_, _slice_, _ctx_)[¶](https://docs.python.org/3/library/ast.html#ast.Subscript "Link to this definition")
A subscript, such as `l[1]`. `value` is the subscripted object (usually sequence or mapping). `slice` is an index, slice or key. It can be a [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple") and contain a [`Slice`](https://docs.python.org/3/library/ast.html#ast.Slice "ast.Slice"). `ctx` is [`Load`](https://docs.python.org/3/library/ast.html#ast.Load "ast.Load"), [`Store`](https://docs.python.org/3/library/ast.html#ast.Store "ast.Store") or [`Del`](https://docs.python.org/3/library/ast.html#ast.Del "ast.Del") according to the action performed with the subscript.

>>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))
Expression(
 body=Subscript(
 value=Name(id='l', ctx=Load()),
 slice=Tuple(
 elts=[
 Slice(
 lower=Constant(value=1),
 upper=Constant(value=2)),
 Constant(value=3)],
 ctx=Load()),
 ctx=Load()))

_class_ ast.Slice(_lower_, _upper_, _step_)[¶](https://docs.python.org/3/library/ast.html#ast.Slice "Link to this definition")
Regular slicing (on the form `lower:upper` or `lower:upper:step`). Can occur only inside the _slice_ field of [`Subscript`](https://docs.python.org/3/library/ast.html#ast.Subscript "ast.Subscript"), either directly or as an element of [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple").

>>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))
Expression(
 body=Subscript(
 value=Name(id='l', ctx=Load()),
 slice=Slice(
 lower=Constant(value=1),
 upper=Constant(value=2)),
 ctx=Load()))

#### Comprehensions[¶](https://docs.python.org/3/library/ast.html#comprehensions "Link to this heading")

_class_ ast.ListComp(_elt_, _generators_)[¶](https://docs.python.org/3/library/ast.html#ast.ListComp "Link to this definition")_class_ ast.SetComp(_elt_, _generators_)[¶](https://docs.python.org/3/library/ast.html#ast.SetComp "Link to this definition")_class_ ast.GeneratorExp(_elt_, _generators_)[¶](https://docs.python.org/3/library/ast.html#ast.GeneratorExp "Link to this definition")_class_ ast.DictComp(_key_, _value_, _generators_)[¶](https://docs.python.org/3/library/ast.html#ast.DictComp "Link to this definition")
List and set comprehensions, generator expressions, and dictionary comprehensions. `elt` (or `key` and `value`) is a single node representing the part that will be evaluated for each item.

`generators` is a list of [`comprehension`](https://docs.python.org/3/library/ast.html#ast.comprehension "ast.comprehension") nodes.

>>> print(ast.dump(
...     ast.parse('[x for x in numbers]', mode='eval'),
...     indent=4,
... ))
Expression(
 body=ListComp(
 elt=Name(id='x', ctx=Load()),
 generators=[
 comprehension(
 target=Name(id='x', ctx=Store()),
 iter=Name(id='numbers', ctx=Load()),
 is_async=0)]))
>>> print(ast.dump(
...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),
...     indent=4,
... ))
Expression(
 body=DictComp(
 key=Name(id='x', ctx=Load()),
 value=BinOp(
 left=Name(id='x', ctx=Load()),
 op=Pow(),
 right=Constant(value=2)),
 generators=[
 comprehension(
 target=Name(id='x', ctx=Store()),
 iter=Name(id='numbers', ctx=Load()),
 is_async=0)]))
>>> print(ast.dump(
...     ast.parse('{x for x in numbers}', mode='eval'),
...     indent=4,
... ))
Expression(
 body=SetComp(
 elt=Name(id='x', ctx=Load()),
 generators=[
 comprehension(
 target=Name(id='x', ctx=Store()),
 iter=Name(id='numbers', ctx=Load()),
 is_async=0)]))

_class_ ast.comprehension(_target_, _iter_, _ifs_, _is\_async_)[¶](https://docs.python.org/3/library/ast.html#ast.comprehension "Link to this definition")
One `for` clause in a comprehension. `target` is the reference to use for each element - typically a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") or [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple") node. `iter` is the object to iterate over. `ifs` is a list of test expressions: each `for` clause can have multiple `ifs`.

`is_async` indicates a comprehension is asynchronous (using an `async for` instead of `for`). The value is an integer (0 or 1).

>>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', mode='eval'),
...                indent=4)) # Multiple comprehensions in one.
Expression(
 body=ListComp(
 elt=Call(
 func=Name(id='ord', ctx=Load()),
 args=[
 Name(id='c', ctx=Load())]),
 generators=[
 comprehension(
 target=Name(id='line', ctx=Store()),
 iter=Name(id='file', ctx=Load()),
 is_async=0),
 comprehension(
 target=Name(id='c', ctx=Store()),
 iter=Name(id='line', ctx=Load()),
 is_async=0)]))

>>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', mode='eval'),
...                indent=4)) # generator comprehension
Expression(
 body=GeneratorExp(
 elt=BinOp(
 left=Name(id='n', ctx=Load()),
 op=Pow(),
 right=Constant(value=2)),
 generators=[
 comprehension(
 target=Name(id='n', ctx=Store()),
 iter=Name(id='it', ctx=Load()),
 ifs=[
 Compare(
 left=Name(id='n', ctx=Load()),
 ops=[
 Gt()],
 comparators=[
 Constant(value=5)]),
 Compare(
 left=Name(id='n', ctx=Load()),
 ops=[
 Lt()],
 comparators=[
 Constant(value=10)])],
 is_async=0)]))

>>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),
...                indent=4)) # Async comprehension
Expression(
 body=ListComp(
 elt=Name(id='i', ctx=Load()),
 generators=[
 comprehension(
 target=Name(id='i', ctx=Store()),
 iter=Name(id='soc', ctx=Load()),
 is_async=1)]))

### Statements[¶](https://docs.python.org/3/library/ast.html#statements "Link to this heading")

_class_ ast.Assign(_targets_, _value_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.Assign "Link to this definition")
An assignment. `targets` is a list of nodes, and `value` is a single node.

Multiple nodes in `targets` represents assigning the same value to each. Unpacking is represented by putting a [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple") or [`List`](https://docs.python.org/3/library/ast.html#ast.List "ast.List") within `targets`.

type_comment[¶](https://docs.python.org/3/library/ast.html#ast.Assign.type_comment "Link to this definition")
`type_comment` is an optional string with the type annotation as a comment.

>>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment
Module(
 body=[
 Assign(
 targets=[
 Name(id='a', ctx=Store()),
 Name(id='b', ctx=Store())],
 value=Constant(value=1))])

>>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking
Module(
 body=[
 Assign(
 targets=[
 Tuple(
 elts=[
 Name(id='a', ctx=Store()),
 Name(id='b', ctx=Store())],
 ctx=Store())],
 value=Name(id='c', ctx=Load()))])

_class_ ast.AnnAssign(_target_, _annotation_, _value_, _simple_)[¶](https://docs.python.org/3/library/ast.html#ast.AnnAssign "Link to this definition")
An assignment with a type annotation. `target` is a single node and can be a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), an [`Attribute`](https://docs.python.org/3/library/ast.html#ast.Attribute "ast.Attribute") or a [`Subscript`](https://docs.python.org/3/library/ast.html#ast.Subscript "ast.Subscript"). `annotation` is the annotation, such as a [`Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant") or [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node. `value` is a single optional node.

`simple` is always either 0 (indicating a “complex” target) or 1 (indicating a “simple” target). A “simple” target consists solely of a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node that does not appear between parentheses; all other targets are considered complex. Only simple targets appear in the [`__annotations__`](https://docs.python.org/3/reference/datamodel.html#object.__annotations__ "object.__annotations__") dictionary of modules and classes.

>>> print(ast.dump(ast.parse('c: int'), indent=4))
Module(
 body=[
 AnnAssign(
 target=Name(id='c', ctx=Store()),
 annotation=Name(id='int', ctx=Load()),
 simple=1)])

>>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with parenthesis
Module(
 body=[
 AnnAssign(
 target=Name(id='a', ctx=Store()),
 annotation=Name(id='int', ctx=Load()),
 value=Constant(value=1),
 simple=0)])

>>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation
Module(
 body=[
 AnnAssign(
 target=Attribute(
 value=Name(id='a', ctx=Load()),
 attr='b',
 ctx=Store()),
 annotation=Name(id='int', ctx=Load()),
 simple=0)])

>>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript annotation
Module(
 body=[
 AnnAssign(
 target=Subscript(
 value=Name(id='a', ctx=Load()),
 slice=Constant(value=1),
 ctx=Store()),
 annotation=Name(id='int', ctx=Load()),
 simple=0)])

_class_ ast.AugAssign(_target_, _op_, _value_)[¶](https://docs.python.org/3/library/ast.html#ast.AugAssign "Link to this definition")
Augmented assignment, such as `a += 1`. In the following example, `target` is a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node for `x` (with the [`Store`](https://docs.python.org/3/library/ast.html#ast.Store "ast.Store") context), `op` is [`Add`](https://docs.python.org/3/library/ast.html#ast.Add "ast.Add"), and `value` is a [`Constant`](https://docs.python.org/3/library/ast.html#ast.Constant "ast.Constant") with value for 1.

The `target` attribute cannot be of class [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple") or [`List`](https://docs.python.org/3/library/ast.html#ast.List "ast.List"), unlike the targets of [`Assign`](https://docs.python.org/3/library/ast.html#ast.Assign "ast.Assign").

>>> print(ast.dump(ast.parse('x += 2'), indent=4))
Module(
 body=[
 AugAssign(
 target=Name(id='x', ctx=Store()),
 op=Add(),
 value=Constant(value=2))])

_class_ ast.Raise(_exc_, _cause_)[¶](https://docs.python.org/3/library/ast.html#ast.Raise "Link to this definition")
A `raise` statement. `exc` is the exception object to be raised, normally a [`Call`](https://docs.python.org/3/library/ast.html#ast.Call "ast.Call") or [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), or `None` for a standalone `raise`. `cause` is the optional part for `y` in `raise x from y`.

>>> print(ast.dump(ast.parse('raise x from y'), indent=4))
Module(
 body=[
 Raise(
 exc=Name(id='x', ctx=Load()),
 cause=Name(id='y', ctx=Load()))])

_class_ ast.Assert(_test_, _msg_)[¶](https://docs.python.org/3/library/ast.html#ast.Assert "Link to this definition")
An assertion. `test` holds the condition, such as a [`Compare`](https://docs.python.org/3/library/ast.html#ast.Compare "ast.Compare") node. `msg` holds the failure message.

>>> print(ast.dump(ast.parse('assert x,y'), indent=4))
Module(
 body=[
 Assert(
 test=Name(id='x', ctx=Load()),
 msg=Name(id='y', ctx=Load()))])

_class_ ast.Delete(_targets_)[¶](https://docs.python.org/3/library/ast.html#ast.Delete "Link to this definition")
Represents a `del` statement. `targets` is a list of nodes, such as [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), [`Attribute`](https://docs.python.org/3/library/ast.html#ast.Attribute "ast.Attribute") or [`Subscript`](https://docs.python.org/3/library/ast.html#ast.Subscript "ast.Subscript") nodes.

>>> print(ast.dump(ast.parse('del x,y,z'), indent=4))
Module(
 body=[
 Delete(
 targets=[
 Name(id='x', ctx=Del()),
 Name(id='y', ctx=Del()),
 Name(id='z', ctx=Del())])])

_class_ ast.Pass[¶](https://docs.python.org/3/library/ast.html#ast.Pass "Link to this definition")
A `pass` statement.

>>> print(ast.dump(ast.parse('pass'), indent=4))
Module(
 body=[
 Pass()])

_class_ ast.TypeAlias(_name_, _type\_params_, _value_)[¶](https://docs.python.org/3/library/ast.html#ast.TypeAlias "Link to this definition")
A [type alias](https://docs.python.org/3/library/typing.html#type-aliases) created through the [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement. `name` is the name of the alias, `type_params` is a list of [type parameters](https://docs.python.org/3/library/ast.html#ast-type-params), and `value` is the value of the type alias.

>>> print(ast.dump(ast.parse('type Alias = int'), indent=4))
Module(
 body=[
 TypeAlias(
 name=Name(id='Alias', ctx=Store()),
 value=Name(id='int', ctx=Load()))])

Added in version 3.12.

Other statements which are only applicable inside functions or loops are described in other sections.

#### Imports[¶](https://docs.python.org/3/library/ast.html#imports "Link to this heading")

_class_ ast.Import(_names_)[¶](https://docs.python.org/3/library/ast.html#ast.Import "Link to this definition")
An import statement. `names` is a list of [`alias`](https://docs.python.org/3/library/ast.html#ast.alias "ast.alias") nodes.

>>> print(ast.dump(ast.parse('import x,y,z'), indent=4))
Module(
 body=[
 Import(
 names=[
 alias(name='x'),
 alias(name='y'),
 alias(name='z')])])

_class_ ast.ImportFrom(_module_, _names_, _level_)[¶](https://docs.python.org/3/library/ast.html#ast.ImportFrom "Link to this definition")
Represents `from x import y`. `module` is a raw string of the ‘from’ name, without any leading dots, or `None` for statements such as `from . import foo`. `level` is an integer holding the level of the relative import (0 means absolute import).

>>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))
Module(
 body=[
 ImportFrom(
 module='y',
 names=[
 alias(name='x'),
 alias(name='y'),
 alias(name='z')],
 level=0)])

_class_ ast.alias(_name_, _asname_)[¶](https://docs.python.org/3/library/ast.html#ast.alias "Link to this definition")
Both parameters are raw strings of the names. `asname` can be `None` if the regular name is to be used.

>>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))
Module(
 body=[
 ImportFrom(
 module='foo.bar',
 names=[
 alias(name='a', asname='b'),
 alias(name='c')],
 level=2)])

### Control flow[¶](https://docs.python.org/3/library/ast.html#control-flow "Link to this heading")

Note

Optional clauses such as `else` are stored as an empty list if they’re not present.

_class_ ast.If(_test_, _body_, _orelse_)[¶](https://docs.python.org/3/library/ast.html#ast.If "Link to this definition")
An `if` statement. `test` holds a single node, such as a [`Compare`](https://docs.python.org/3/library/ast.html#ast.Compare "ast.Compare") node. `body` and `orelse` each hold a list of nodes.

`elif` clauses don’t have a special representation in the AST, but rather appear as extra [`If`](https://docs.python.org/3/library/ast.html#ast.If "ast.If") nodes within the `orelse` section of the previous one.

>>> print(ast.dump(ast.parse("""
... if x:
...  ...
... elif y:
...  ...
... else:
...  ...
... """), indent=4))
Module(
 body=[
 If(
 test=Name(id='x', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 orelse=[
 If(
 test=Name(id='y', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 orelse=[
 Expr(
 value=Constant(value=Ellipsis))])])])

_class_ ast.For(_target_, _iter_, _body_, _orelse_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.For "Link to this definition")
A `for` loop. `target` holds the variable(s) the loop assigns to, as a single [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple"), [`List`](https://docs.python.org/3/library/ast.html#ast.List "ast.List"), [`Attribute`](https://docs.python.org/3/library/ast.html#ast.Attribute "ast.Attribute") or [`Subscript`](https://docs.python.org/3/library/ast.html#ast.Subscript "ast.Subscript") node. `iter` holds the item to be looped over, again as a single node. `body` and `orelse` contain lists of nodes to execute. Those in `orelse` are executed if the loop finishes normally, rather than via a `break` statement.

type_comment[¶](https://docs.python.org/3/library/ast.html#ast.For.type_comment "Link to this definition")
`type_comment` is an optional string with the type annotation as a comment.

>>> print(ast.dump(ast.parse("""
... for x in y:
...  ...
... else:
...  ...
... """), indent=4))
Module(
 body=[
 For(
 target=Name(id='x', ctx=Store()),
 iter=Name(id='y', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 orelse=[
 Expr(
 value=Constant(value=Ellipsis))])])

_class_ ast.While(_test_, _body_, _orelse_)[¶](https://docs.python.org/3/library/ast.html#ast.While "Link to this definition")
A `while` loop. `test` holds the condition, such as a [`Compare`](https://docs.python.org/3/library/ast.html#ast.Compare "ast.Compare") node.

>>> print(ast.dump(ast.parse("""
... while x:
...  ...
... else:
...  ...
... """), indent=4))
Module(
 body=[
 While(
 test=Name(id='x', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 orelse=[
 Expr(
 value=Constant(value=Ellipsis))])])

_class_ ast.Break[¶](https://docs.python.org/3/library/ast.html#ast.Break "Link to this definition")_class_ ast.Continue[¶](https://docs.python.org/3/library/ast.html#ast.Continue "Link to this definition")
The `break` and `continue` statements.

>>> print(ast.dump(ast.parse("""\
... for a in b:
...  if a > 5:
...  break
...  else:
...  continue
...
... """), indent=4))
Module(
 body=[
 For(
 target=Name(id='a', ctx=Store()),
 iter=Name(id='b', ctx=Load()),
 body=[
 If(
 test=Compare(
 left=Name(id='a', ctx=Load()),
 ops=[
 Gt()],
 comparators=[
 Constant(value=5)]),
 body=[
 Break()],
 orelse=[
 Continue()])])])

_class_ ast.Try(_body_, _handlers_, _orelse_, _finalbody_)[¶](https://docs.python.org/3/library/ast.html#ast.Try "Link to this definition")
`try` blocks. All attributes are list of nodes to execute, except for `handlers`, which is a list of [`ExceptHandler`](https://docs.python.org/3/library/ast.html#ast.ExceptHandler "ast.ExceptHandler") nodes.

>>> print(ast.dump(ast.parse("""
... try:
...  ...
... except Exception:
...  ...
... except OtherException as e:
...  ...
... else:
...  ...
... finally:
...  ...
... """), indent=4))
Module(
 body=[
 Try(
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 handlers=[
 ExceptHandler(
 type=Name(id='Exception', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 ExceptHandler(
 type=Name(id='OtherException', ctx=Load()),
 name='e',
 body=[
 Expr(
 value=Constant(value=Ellipsis))])],
 orelse=[
 Expr(
 value=Constant(value=Ellipsis))],
 finalbody=[
 Expr(
 value=Constant(value=Ellipsis))])])

_class_ ast.TryStar(_body_, _handlers_, _orelse_, _finalbody_)[¶](https://docs.python.org/3/library/ast.html#ast.TryStar "Link to this definition")
`try` blocks which are followed by `except*` clauses. The attributes are the same as for [`Try`](https://docs.python.org/3/library/ast.html#ast.Try "ast.Try") but the [`ExceptHandler`](https://docs.python.org/3/library/ast.html#ast.ExceptHandler "ast.ExceptHandler") nodes in `handlers` are interpreted as `except*` blocks rather then `except`.

>>> print(ast.dump(ast.parse("""
... try:
...  ...
... except* Exception:
...  ...
... """), indent=4))
Module(
 body=[
 TryStar(
 body=[
 Expr(
 value=Constant(value=Ellipsis))],
 handlers=[
 ExceptHandler(
 type=Name(id='Exception', ctx=Load()),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.11.

_class_ ast.ExceptHandler(_type_, _name_, _body_)[¶](https://docs.python.org/3/library/ast.html#ast.ExceptHandler "Link to this definition")
A single `except` clause. `type` is the exception type it will match, typically a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node (or `None` for a catch-all `except:` clause). `name` is a raw string for the name to hold the exception, or `None` if the clause doesn’t have `as foo`. `body` is a list of nodes.

>>> print(ast.dump(ast.parse("""\
... try:
...  a + 1
... except TypeError:
...  pass
... """), indent=4))
Module(
 body=[
 Try(
 body=[
 Expr(
 value=BinOp(
 left=Name(id='a', ctx=Load()),
 op=Add(),
 right=Constant(value=1)))],
 handlers=[
 ExceptHandler(
 type=Name(id='TypeError', ctx=Load()),
 body=[
 Pass()])])])

_class_ ast.With(_items_, _body_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.With "Link to this definition")
A `with` block. `items` is a list of [`withitem`](https://docs.python.org/3/library/ast.html#ast.withitem "ast.withitem") nodes representing the context managers, and `body` is the indented block inside the context.

type_comment[¶](https://docs.python.org/3/library/ast.html#ast.With.type_comment "Link to this definition")
`type_comment` is an optional string with the type annotation as a comment.

_class_ ast.withitem(_context\_expr_, _optional\_vars_)[¶](https://docs.python.org/3/library/ast.html#ast.withitem "Link to this definition")
A single context manager in a `with` block. `context_expr` is the context manager, often a [`Call`](https://docs.python.org/3/library/ast.html#ast.Call "ast.Call") node. `optional_vars` is a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name"), [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple") or [`List`](https://docs.python.org/3/library/ast.html#ast.List "ast.List") for the `as foo` part, or `None` if that isn’t used.

>>> print(ast.dump(ast.parse("""\
... with a as b, c as d:
...  something(b, d)
... """), indent=4))
Module(
 body=[
 With(
 items=[
 withitem(
 context_expr=Name(id='a', ctx=Load()),
 optional_vars=Name(id='b', ctx=Store())),
 withitem(
 context_expr=Name(id='c', ctx=Load()),
 optional_vars=Name(id='d', ctx=Store()))],
 body=[
 Expr(
 value=Call(
 func=Name(id='something', ctx=Load()),
 args=[
 Name(id='b', ctx=Load()),
 Name(id='d', ctx=Load())]))])])

### Pattern matching[¶](https://docs.python.org/3/library/ast.html#pattern-matching "Link to this heading")

_class_ ast.Match(_subject_, _cases_)[¶](https://docs.python.org/3/library/ast.html#ast.Match "Link to this definition")
A `match` statement. `subject` holds the subject of the match (the object that is being matched against the cases) and `cases` contains an iterable of [`match_case`](https://docs.python.org/3/library/ast.html#ast.match_case "ast.match_case") nodes with the different cases.

Added in version 3.10.

_class_ ast.match_case(_pattern_, _guard_, _body_)[¶](https://docs.python.org/3/library/ast.html#ast.match_case "Link to this definition")
A single case pattern in a `match` statement. `pattern` contains the match pattern that the subject will be matched against. Note that the [`AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") nodes produced for patterns differ from those produced for expressions, even when they share the same syntax.

The `guard` attribute contains an expression that will be evaluated if the pattern matches the subject.

`body` contains a list of nodes to execute if the pattern matches and the result of evaluating the guard expression is true.

>>> print(ast.dump(ast.parse("""
... match x:
...  case [x] if x>0:
...  ...
...  case tuple():
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchSequence(
 patterns=[
 MatchAs(name='x')]),
 guard=Compare(
 left=Name(id='x', ctx=Load()),
 ops=[
 Gt()],
 comparators=[
 Constant(value=0)]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 match_case(
 pattern=MatchClass(
 cls=Name(id='tuple', ctx=Load())),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchValue(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchValue "Link to this definition")
A match literal or value pattern that compares by equality. `value` is an expression node. Permitted value nodes are restricted as described in the match statement documentation. This pattern succeeds if the match subject is equal to the evaluated value.

>>> print(ast.dump(ast.parse("""
... match x:
...  case "Relevant":
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchValue(
 value=Constant(value='Relevant')),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchSingleton(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchSingleton "Link to this definition")
A match literal pattern that compares by identity. `value` is the singleton to be compared against: `None`, `True`, or `False`. This pattern succeeds if the match subject is the given constant.

>>> print(ast.dump(ast.parse("""
... match x:
...  case None:
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchSingleton(value=None),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchSequence(_patterns_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchSequence "Link to this definition")
A match sequence pattern. `patterns` contains the patterns to be matched against the subject elements if the subject is a sequence. Matches a variable length sequence if one of the subpatterns is a `MatchStar` node, otherwise matches a fixed length sequence.

>>> print(ast.dump(ast.parse("""
... match x:
...  case [1, 2]:
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchSequence(
 patterns=[
 MatchValue(
 value=Constant(value=1)),
 MatchValue(
 value=Constant(value=2))]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchStar(_name_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchStar "Link to this definition")
Matches the rest of the sequence in a variable length match sequence pattern. If `name` is not `None`, a list containing the remaining sequence elements is bound to that name if the overall sequence pattern is successful.

>>> print(ast.dump(ast.parse("""
... match x:
...  case [1, 2, *rest]:
...  ...
...  case [*_]:
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchSequence(
 patterns=[
 MatchValue(
 value=Constant(value=1)),
 MatchValue(
 value=Constant(value=2)),
 MatchStar(name='rest')]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 match_case(
 pattern=MatchSequence(
 patterns=[
 MatchStar()]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchMapping(_keys_, _patterns_, _rest_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchMapping "Link to this definition")
A match mapping pattern. `keys` is a sequence of expression nodes. `patterns` is a corresponding sequence of pattern nodes. `rest` is an optional name that can be specified to capture the remaining mapping elements. Permitted key expressions are restricted as described in the match statement documentation.

This pattern succeeds if the subject is a mapping, all evaluated key expressions are present in the mapping, and the value corresponding to each key matches the corresponding subpattern. If `rest` is not `None`, a dict containing the remaining mapping elements is bound to that name if the overall mapping pattern is successful.

>>> print(ast.dump(ast.parse("""
... match x:
...  case {1: _, 2: _}:
...  ...
...  case {**rest}:
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchMapping(
 keys=[
 Constant(value=1),
 Constant(value=2)],
 patterns=[
 MatchAs(),
 MatchAs()]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 match_case(
 pattern=MatchMapping(rest='rest'),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchClass(_cls_, _patterns_, _kwd\_attrs_, _kwd\_patterns_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchClass "Link to this definition")
A match class pattern. `cls` is an expression giving the nominal class to be matched. `patterns` is a sequence of pattern nodes to be matched against the class defined sequence of pattern matching attributes. `kwd_attrs` is a sequence of additional attributes to be matched (specified as keyword arguments in the class pattern), `kwd_patterns` are the corresponding patterns (specified as keyword values in the class pattern).

This pattern succeeds if the subject is an instance of the nominated class, all positional patterns match the corresponding class-defined attributes, and any specified keyword attributes match their corresponding pattern.

Note: classes may define a property that returns self in order to match a pattern node against the instance being matched. Several builtin types are also matched that way, as described in the match statement documentation.

>>> print(ast.dump(ast.parse("""
... match x:
...  case Point2D(0, 0):
...  ...
...  case Point3D(x=0, y=0, z=0):
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchClass(
 cls=Name(id='Point2D', ctx=Load()),
 patterns=[
 MatchValue(
 value=Constant(value=0)),
 MatchValue(
 value=Constant(value=0))]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 match_case(
 pattern=MatchClass(
 cls=Name(id='Point3D', ctx=Load()),
 kwd_attrs=[
 'x',
 'y',
 'z'],
 kwd_patterns=[
 MatchValue(
 value=Constant(value=0)),
 MatchValue(
 value=Constant(value=0)),
 MatchValue(
 value=Constant(value=0))]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchAs(_pattern_, _name_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchAs "Link to this definition")
A match “as-pattern”, capture pattern or wildcard pattern. `pattern` contains the match pattern that the subject will be matched against. If the pattern is `None`, the node represents a capture pattern (i.e a bare name) and will always succeed.

The `name` attribute contains the name that will be bound if the pattern is successful. If `name` is `None`, `pattern` must also be `None` and the node represents the wildcard pattern.

>>> print(ast.dump(ast.parse("""
... match x:
...  case [x] as y:
...  ...
...  case _:
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchAs(
 pattern=MatchSequence(
 patterns=[
 MatchAs(name='x')]),
 name='y'),
 body=[
 Expr(
 value=Constant(value=Ellipsis))]),
 match_case(
 pattern=MatchAs(),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

_class_ ast.MatchOr(_patterns_)[¶](https://docs.python.org/3/library/ast.html#ast.MatchOr "Link to this definition")
A match “or-pattern”. An or-pattern matches each of its subpatterns in turn to the subject, until one succeeds. The or-pattern is then deemed to succeed. If none of the subpatterns succeed the or-pattern fails. The `patterns` attribute contains a list of match pattern nodes that will be matched against the subject.

>>> print(ast.dump(ast.parse("""
... match x:
...  case [x] | (y):
...  ...
... """), indent=4))
Module(
 body=[
 Match(
 subject=Name(id='x', ctx=Load()),
 cases=[
 match_case(
 pattern=MatchOr(
 patterns=[
 MatchSequence(
 patterns=[
 MatchAs(name='x')]),
 MatchAs(name='y')]),
 body=[
 Expr(
 value=Constant(value=Ellipsis))])])])

Added in version 3.10.

### Type annotations[¶](https://docs.python.org/3/library/ast.html#type-annotations "Link to this heading")

_class_ ast.TypeIgnore(_lineno_, _tag_)[¶](https://docs.python.org/3/library/ast.html#ast.TypeIgnore "Link to this definition")
A `# type: ignore` comment located at _lineno_. _tag_ is the optional tag specified by the form `# type: ignore <tag>`.

>>> print(ast.dump(ast.parse('x = 1 # type: ignore', type_comments=True), indent=4))
Module(
 body=[
 Assign(
 targets=[
 Name(id='x', ctx=Store())],
 value=Constant(value=1))],
 type_ignores=[
 TypeIgnore(lineno=1, tag='')])
>>> print(ast.dump(ast.parse('x: bool = 1 # type: ignore[assignment]', type_comments=True), indent=4))
Module(
 body=[
 AnnAssign(
 target=Name(id='x', ctx=Store()),
 annotation=Name(id='bool', ctx=Load()),
 value=Constant(value=1),
 simple=1)],
 type_ignores=[
 TypeIgnore(lineno=1, tag='[assignment]')])

Note

`TypeIgnore` nodes are not generated when the _type\_comments_ parameter is set to `False` (default). See [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") for more details.

Added in version 3.8.

### Type parameters[¶](https://docs.python.org/3/library/ast.html#type-parameters "Link to this heading")

[Type parameters](https://docs.python.org/3/reference/compound_stmts.html#type-params) can exist on classes, functions, and type aliases.

_class_ ast.TypeVar(_name_, _bound_, _default\_value_)[¶](https://docs.python.org/3/library/ast.html#ast.TypeVar "Link to this definition")
A [`typing.TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "typing.TypeVar"). `name` is the name of the type variable. `bound` is the bound or constraints, if any. If `bound` is a [`Tuple`](https://docs.python.org/3/library/ast.html#ast.Tuple "ast.Tuple"), it represents constraints; otherwise it represents the bound. `default_value` is the default value; if the `TypeVar` has no default, this attribute will be set to `None`.

>>> print(ast.dump(ast.parse("type Alias[T: int = bool] = list[T]"), indent=4))
Module(
 body=[
 TypeAlias(
 name=Name(id='Alias', ctx=Store()),
 type_params=[
 TypeVar(
 name='T',
 bound=Name(id='int', ctx=Load()),
 default_value=Name(id='bool', ctx=Load()))],
 value=Subscript(
 value=Name(id='list', ctx=Load()),
 slice=Name(id='T', ctx=Load()),
 ctx=Load()))])

Added in version 3.12.

Changed in version 3.13: Added the _default\_value_ parameter.

_class_ ast.ParamSpec(_name_, _default\_value_)[¶](https://docs.python.org/3/library/ast.html#ast.ParamSpec "Link to this definition")
A [`typing.ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec"). `name` is the name of the parameter specification. `default_value` is the default value; if the `ParamSpec` has no default, this attribute will be set to `None`.

>>> print(ast.dump(ast.parse("type Alias[**P = [int, str]] = Callable[P, int]"), indent=4))
Module(
 body=[
 TypeAlias(
 name=Name(id='Alias', ctx=Store()),
 type_params=[
 ParamSpec(
 name='P',
 default_value=List(
 elts=[
 Name(id='int', ctx=Load()),
 Name(id='str', ctx=Load())],
 ctx=Load()))],
 value=Subscript(
 value=Name(id='Callable', ctx=Load()),
 slice=Tuple(
 elts=[
 Name(id='P', ctx=Load()),
 Name(id='int', ctx=Load())],
 ctx=Load()),
 ctx=Load()))])

Added in version 3.12.

Changed in version 3.13: Added the _default\_value_ parameter.

_class_ ast.TypeVarTuple(_name_, _default\_value_)[¶](https://docs.python.org/3/library/ast.html#ast.TypeVarTuple "Link to this definition")
A [`typing.TypeVarTuple`](https://docs.python.org/3/library/typing.html#typing.TypeVarTuple "typing.TypeVarTuple"). `name` is the name of the type variable tuple. `default_value` is the default value; if the `TypeVarTuple` has no default, this attribute will be set to `None`.

>>> print(ast.dump(ast.parse("type Alias[*Ts = ()] = tuple[*Ts]"), indent=4))
Module(
 body=[
 TypeAlias(
 name=Name(id='Alias', ctx=Store()),
 type_params=[
 TypeVarTuple(
 name='Ts',
 default_value=Tuple(ctx=Load()))],
 value=Subscript(
 value=Name(id='tuple', ctx=Load()),
 slice=Tuple(
 elts=[
 Starred(
 value=Name(id='Ts', ctx=Load()),
 ctx=Load())],
 ctx=Load()),
 ctx=Load()))])

Added in version 3.12.

Changed in version 3.13: Added the _default\_value_ parameter.

### Function and class definitions[¶](https://docs.python.org/3/library/ast.html#function-and-class-definitions "Link to this heading")

_class_ ast.FunctionDef(_name_, _args_, _body_, _decorator\_list_, _returns_, _type\_comment_, _type\_params_)[¶](https://docs.python.org/3/library/ast.html#ast.FunctionDef "Link to this definition")
A function definition.

*   `name` is a raw string of the function name.

*   `args` is an [`arguments`](https://docs.python.org/3/library/ast.html#ast.arguments "ast.arguments") node.

*   `body` is the list of nodes inside the function.

*   `decorator_list` is the list of decorators to be applied, stored outermost first (i.e. the first in the list will be applied last).

*   `returns` is the return annotation.

*   `type_params` is a list of [type parameters](https://docs.python.org/3/library/ast.html#ast-type-params).

type_comment[¶](https://docs.python.org/3/library/ast.html#ast.FunctionDef.type_comment "Link to this definition")
`type_comment` is an optional string with the type annotation as a comment.

Changed in version 3.12: Added `type_params`.

_class_ ast.Lambda(_args_, _body_)[¶](https://docs.python.org/3/library/ast.html#ast.Lambda "Link to this definition")
`lambda` is a minimal function definition that can be used inside an expression. Unlike [`FunctionDef`](https://docs.python.org/3/library/ast.html#ast.FunctionDef "ast.FunctionDef"), `body` holds a single node.

>>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))
Module(
 body=[
 Expr(
 value=Lambda(
 args=arguments(
 args=[
 arg(arg='x'),
 arg(arg='y')]),
 body=Constant(value=Ellipsis)))])

_class_ ast.arguments(_posonlyargs_, _args_, _vararg_, _kwonlyargs_, _kw\_defaults_, _kwarg_, _defaults_)[¶](https://docs.python.org/3/library/ast.html#ast.arguments "Link to this definition")
The arguments for a function.

*   `posonlyargs`, `args` and `kwonlyargs` are lists of [`arg`](https://docs.python.org/3/library/ast.html#ast.arg "ast.arg") nodes.

*   `vararg` and `kwarg` are single [`arg`](https://docs.python.org/3/library/ast.html#ast.arg "ast.arg") nodes, referring to the `*args, **kwargs` parameters.

*   `kw_defaults` is a list of default values for keyword-only arguments. If one is `None`, the corresponding argument is required.

*   `defaults` is a list of default values for arguments that can be passed positionally. If there are fewer defaults, they correspond to the last n arguments.

_class_ ast.arg(_arg_, _annotation_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.arg "Link to this definition")
A single argument in a list. `arg` is a raw string of the argument name; `annotation` is its annotation, such as a [`Name`](https://docs.python.org/3/library/ast.html#ast.Name "ast.Name") node.

type_comment[¶](https://docs.python.org/3/library/ast.html#ast.arg.type_comment "Link to this definition")
`type_comment` is an optional string with the type annotation as a comment

>>> print(ast.dump(ast.parse("""\
... @decorator1
... @decorator2
... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return annotation':
...  pass
... """), indent=4))
Module(
 body=[
 FunctionDef(
 name='f',
 args=arguments(
 args=[
 arg(
 arg='a',
 annotation=Constant(value='annotation')),
 arg(arg='b'),
 arg(arg='c')],
 vararg=arg(arg='d'),
 kwonlyargs=[
 arg(arg='e'),
 arg(arg='f')],
 kw_defaults=[
 None,
 Constant(value=3)],
 kwarg=arg(arg='g'),
 defaults=[
 Constant(value=1),
 Constant(value=2)]),
 body=[
 Pass()],
 decorator_list=[
 Name(id='decorator1', ctx=Load()),
 Name(id='decorator2', ctx=Load())],
 returns=Constant(value='return annotation'))])

_class_ ast.Return(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.Return "Link to this definition")
A `return` statement.

>>> print(ast.dump(ast.parse('return 4'), indent=4))
Module(
 body=[
 Return(
 value=Constant(value=4))])

_class_ ast.Yield(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.Yield "Link to this definition")_class_ ast.YieldFrom(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.YieldFrom "Link to this definition")
A `yield` or `yield from` expression. Because these are expressions, they must be wrapped in an [`Expr`](https://docs.python.org/3/library/ast.html#ast.Expr "ast.Expr") node if the value sent back is not used.

>>> print(ast.dump(ast.parse('yield x'), indent=4))
Module(
 body=[
 Expr(
 value=Yield(
 value=Name(id='x', ctx=Load())))])

>>> print(ast.dump(ast.parse('yield from x'), indent=4))
Module(
 body=[
 Expr(
 value=YieldFrom(
 value=Name(id='x', ctx=Load())))])

_class_ ast.Global(_names_)[¶](https://docs.python.org/3/library/ast.html#ast.Global "Link to this definition")_class_ ast.Nonlocal(_names_)[¶](https://docs.python.org/3/library/ast.html#ast.Nonlocal "Link to this definition")
`global` and `nonlocal` statements. `names` is a list of raw strings.

>>> print(ast.dump(ast.parse('global x,y,z'), indent=4))
Module(
 body=[
 Global(
 names=[
 'x',
 'y',
 'z'])])

>>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))
Module(
 body=[
 Nonlocal(
 names=[
 'x',
 'y',
 'z'])])

_class_ ast.ClassDef(_name_, _bases_, _keywords_, _body_, _decorator\_list_, _type\_params_)[¶](https://docs.python.org/3/library/ast.html#ast.ClassDef "Link to this definition")
A class definition.

*   `name` is a raw string for the class name

*   `bases` is a list of nodes for explicitly specified base classes.

*   `keywords` is a list of [`keyword`](https://docs.python.org/3/library/ast.html#ast.keyword "ast.keyword") nodes, principally for ‘metaclass’. Other keywords will be passed to the metaclass, as per [**PEP 3115**](https://peps.python.org/pep-3115/).

*   `body` is a list of nodes representing the code within the class definition.

*   `decorator_list` is a list of nodes, as in [`FunctionDef`](https://docs.python.org/3/library/ast.html#ast.FunctionDef "ast.FunctionDef").

*   `type_params` is a list of [type parameters](https://docs.python.org/3/library/ast.html#ast-type-params).

>>> print(ast.dump(ast.parse("""\
... @decorator1
... @decorator2
... class Foo(base1, base2, metaclass=meta):
...  pass
... """), indent=4))
Module(
 body=[
 ClassDef(
 name='Foo',
 bases=[
 Name(id='base1', ctx=Load()),
 Name(id='base2', ctx=Load())],
 keywords=[
 keyword(
 arg='metaclass',
 value=Name(id='meta', ctx=Load()))],
 body=[
 Pass()],
 decorator_list=[
 Name(id='decorator1', ctx=Load()),
 Name(id='decorator2', ctx=Load())])])

Changed in version 3.12: Added `type_params`.

### Async and await[¶](https://docs.python.org/3/library/ast.html#async-and-await "Link to this heading")

_class_ ast.AsyncFunctionDef(_name_, _args_, _body_, _decorator\_list_, _returns_, _type\_comment_, _type\_params_)[¶](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "Link to this definition")
An `async def` function definition. Has the same fields as [`FunctionDef`](https://docs.python.org/3/library/ast.html#ast.FunctionDef "ast.FunctionDef").

Changed in version 3.12: Added `type_params`.

_class_ ast.Await(_value_)[¶](https://docs.python.org/3/library/ast.html#ast.Await "Link to this definition")
An `await` expression. `value` is what it waits for. Only valid in the body of an [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef").

>>> print(ast.dump(ast.parse("""\
... async def f():
...  await other_func()
... """), indent=4))
Module(
 body=[
 AsyncFunctionDef(
 name='f',
 args=arguments(),
 body=[
 Expr(
 value=Await(
 value=Call(
 func=Name(id='other_func', ctx=Load()))))])])

_class_ ast.AsyncFor(_target_, _iter_, _body_, _orelse_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.AsyncFor "Link to this definition")_class_ ast.AsyncWith(_items_, _body_, _type\_comment_)[¶](https://docs.python.org/3/library/ast.html#ast.AsyncWith "Link to this definition")
`async for` loops and `async with` context managers. They have the same fields as [`For`](https://docs.python.org/3/library/ast.html#ast.For "ast.For") and [`With`](https://docs.python.org/3/library/ast.html#ast.With "ast.With"), respectively. Only valid in the body of an [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef").

Note

When a string is parsed by [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse"), operator nodes (subclasses of `ast.operator`, `ast.unaryop`, `ast.cmpop`, `ast.boolop` and `ast.expr_context`) on the returned tree will be singletons. Changes to one will be reflected in all other occurrences of the same value (for example, [`ast.Add`](https://docs.python.org/3/library/ast.html#ast.Add "ast.Add")).

[`ast`](https://docs.python.org/3/library/ast.html#module-ast "ast: Abstract Syntax Tree classes and manipulation.") helpers[¶](https://docs.python.org/3/library/ast.html#ast-helpers "Link to this heading")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Apart from the node classes, the [`ast`](https://docs.python.org/3/library/ast.html#module-ast "ast: Abstract Syntax Tree classes and manipulation.") module defines these utility functions and classes for traversing abstract syntax trees:

ast.parse(_source_, _filename='<unknown>'_, _mode='exec'_, _*_, _type\_comments=False_, _feature\_version=None_, _optimize=-1_)[¶](https://docs.python.org/3/library/ast.html#ast.parse "Link to this definition")
Parse the source into an AST node. Equivalent to 
```
compile(source,
filename, mode, flags=FLAGS_VALUE, optimize=optimize)
```
, where `FLAGS_VALUE` is `ast.PyCF_ONLY_AST` if `optimize <= 0` and `ast.PyCF_OPTIMIZED_AST` otherwise.

If `type_comments=True` is given, the parser is modified to check and return type comments as specified by [**PEP 484**](https://peps.python.org/pep-0484/) and [**PEP 526**](https://peps.python.org/pep-0526/). This is equivalent to adding [`ast.PyCF_TYPE_COMMENTS`](https://docs.python.org/3/library/ast.html#ast.PyCF_TYPE_COMMENTS "ast.PyCF_TYPE_COMMENTS") to the flags passed to [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile"). This will report syntax errors for misplaced type comments. Without this flag, type comments will be ignored, and the `type_comment` field on selected AST nodes will always be `None`. In addition, the locations of 
```
# type:
ignore
```
 comments will be returned as the `type_ignores` attribute of [`Module`](https://docs.python.org/3/library/ast.html#ast.Module "ast.Module") (otherwise it is always an empty list).

In addition, if `mode` is `'func_type'`, the input syntax is modified to correspond to [**PEP 484**](https://peps.python.org/pep-0484/) “signature type comments”, e.g. `(str, int) -> List[str]`.

Setting `feature_version` to a tuple `(major, minor)` will result in a “best-effort” attempt to parse using that Python version’s grammar. For example, setting `feature_version=(3, 9)` will attempt to disallow parsing of [`match`](https://docs.python.org/3/reference/compound_stmts.html#match) statements. Currently `major` must equal to `3`. The lowest supported version is `(3, 7)` (and this may increase in future Python versions); the highest is `sys.version_info[0:2]`. “Best-effort” attempt means there is no guarantee that the parse (or success of the parse) is the same as when run on the Python version corresponding to `feature_version`.

If source contains a null character (`\0`), [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised.

Warning

Note that successfully parsing source code into an AST object doesn’t guarantee that the source code provided is valid Python code that can be executed as the compilation step can raise further [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError") exceptions. For instance, the source `return 42` generates a valid AST node for a return statement, but it cannot be compiled alone (it needs to be inside a function node).

In particular, [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse") won’t do any scoping checks, which the compilation step does.

Warning

It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python’s AST compiler.

Changed in version 3.8: Added `type_comments`, `mode='func_type'` and `feature_version`.

Changed in version 3.13: The minimum supported version for `feature_version` is now `(3, 7)`. The `optimize` argument was added.

ast.unparse(_ast\_obj_)[¶](https://docs.python.org/3/library/ast.html#ast.unparse "Link to this definition")
Unparse an [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object and generate a string with code that would produce an equivalent [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object if parsed back with [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse").

Warning

The produced code string will not necessarily be equal to the original code that generated the [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object (without any compiler optimizations, such as constant tuples/frozensets).

Warning

Trying to unparse a highly complex expression would result with [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError "RecursionError").

Added in version 3.9.

ast.literal_eval(_node\_or\_string_)[¶](https://docs.python.org/3/library/ast.html#ast.literal_eval "Link to this definition")
Evaluate an expression node or a string containing only a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, `None` and `Ellipsis`.

This can be used for evaluating strings containing Python values without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.

This function had been documented as “safe” in the past without defining what that meant. That was misleading. This is specifically designed not to execute Python code, unlike the more general [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval"). There is no namespace, no name lookups, or ability to call out. But it is not free from attack: A relatively small input can lead to memory exhaustion or to C stack exhaustion, crashing the process. There is also the possibility for excessive CPU consumption denial of service on some inputs. Calling it on untrusted data is thus not recommended.

Warning

It is possible to crash the Python interpreter due to stack depth limitations in Python’s AST compiler.

It can raise [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError"), [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"), [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError"), [`MemoryError`](https://docs.python.org/3/library/exceptions.html#MemoryError "MemoryError") and [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError "RecursionError") depending on the malformed input.

Changed in version 3.2: Now allows bytes and set literals.

Changed in version 3.9: Now supports creating empty sets with `'set()'`.

Changed in version 3.10: For string inputs, leading spaces and tabs are now stripped.

ast.get_docstring(_node_, _clean=True_)[¶](https://docs.python.org/3/library/ast.html#ast.get_docstring "Link to this definition")
Return the docstring of the given _node_ (which must be a [`FunctionDef`](https://docs.python.org/3/library/ast.html#ast.FunctionDef "ast.FunctionDef"), [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef"), [`ClassDef`](https://docs.python.org/3/library/ast.html#ast.ClassDef "ast.ClassDef"), or [`Module`](https://docs.python.org/3/library/ast.html#ast.Module "ast.Module") node), or `None` if it has no docstring. If _clean_ is true, clean up the docstring’s indentation with [`inspect.cleandoc()`](https://docs.python.org/3/library/inspect.html#inspect.cleandoc "inspect.cleandoc").

Changed in version 3.5: [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef") is now supported.

ast.get_source_segment(_source_, _node_, _*_, _padded=False_)[¶](https://docs.python.org/3/library/ast.html#ast.get_source_segment "Link to this definition")
Get source code segment of the _source_ that generated _node_. If some location information ([`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno"), [`end_lineno`](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "ast.AST.end_lineno"), [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset"), or [`end_col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "ast.AST.end_col_offset")) is missing, return `None`.

If _padded_ is `True`, the first line of a multi-line statement will be padded with spaces to match its original position.

Added in version 3.8.

ast.fix_missing_locations(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.fix_missing_locations "Link to this definition")
When you compile a node tree with [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile"), the compiler expects [`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno") and [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset") attributes for every node that supports them. This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node. It works recursively starting at _node_.

ast.increment_lineno(_node_, _n=1_)[¶](https://docs.python.org/3/library/ast.html#ast.increment_lineno "Link to this definition")
Increment the line number and end line number of each node in the tree starting at _node_ by _n_. This is useful to “move code” to a different location in a file.

ast.copy_location(_new\_node_, _old\_node_)[¶](https://docs.python.org/3/library/ast.html#ast.copy_location "Link to this definition")
Copy source location ([`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno"), [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset"), [`end_lineno`](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "ast.AST.end_lineno"), and [`end_col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "ast.AST.end_col_offset")) from _old\_node_ to _new\_node_ if possible, and return _new\_node_.

ast.iter_fields(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.iter_fields "Link to this definition")
Yield a tuple of `(fieldname, value)` for each field in `node._fields` that is present on _node_.

ast.iter_child_nodes(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.iter_child_nodes "Link to this definition")
Yield all direct child nodes of _node_, that is, all fields that are nodes and all items of fields that are lists of nodes.

ast.walk(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.walk "Link to this definition")
Recursively yield all descendant nodes in the tree starting at _node_ (including _node_ itself), in no specified order. This is useful if you only want to modify nodes in place and don’t care about the context.

_class_ ast.NodeVisitor[¶](https://docs.python.org/3/library/ast.html#ast.NodeVisitor "Link to this definition")
A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the [`visit()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.visit "ast.NodeVisitor.visit") method.

This class is meant to be subclassed, with the subclass adding visitor methods.

visit(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.visit "Link to this definition")
Visit a node. The default implementation calls the method called `self.visit_classname` where _classname_ is the name of the node class, or [`generic_visit()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.generic_visit "ast.NodeVisitor.generic_visit") if that method doesn’t exist.

generic_visit(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.generic_visit "Link to this definition")
This visitor calls [`visit()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.visit "ast.NodeVisitor.visit") on all children of the node.

Note that child nodes of nodes that have a custom visitor method won’t be visited unless the visitor calls [`generic_visit()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.generic_visit "ast.NodeVisitor.generic_visit") or visits them itself.

visit_Constant(_node_)[¶](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.visit_Constant "Link to this definition")
Handles all constant nodes.

Don’t use the [`NodeVisitor`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor "ast.NodeVisitor") if you want to apply changes to nodes during traversal. For this a special visitor exists ([`NodeTransformer`](https://docs.python.org/3/library/ast.html#ast.NodeTransformer "ast.NodeTransformer")) that allows modifications.

Deprecated since version 3.8, removed in version 3.14: Methods `visit_Num()`, `visit_Str()`, `visit_Bytes()`, `visit_NameConstant()` and `visit_Ellipsis()` will not be called in Python 3.14+. Add the [`visit_Constant()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.visit_Constant "ast.NodeVisitor.visit_Constant") method instead to handle all constant nodes.

_class_ ast.NodeTransformer[¶](https://docs.python.org/3/library/ast.html#ast.NodeTransformer "Link to this definition")
A [`NodeVisitor`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor "ast.NodeVisitor") subclass that walks the abstract syntax tree and allows modification of nodes.

The [`NodeTransformer`](https://docs.python.org/3/library/ast.html#ast.NodeTransformer "ast.NodeTransformer") will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is `None`, the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place.

Here is an example transformer that rewrites all occurrences of name lookups (`foo`) to `data['foo']`:

class RewriteName(NodeTransformer):

    def visit_Name(self, node):
        return Subscript(
            value=Name(id='data', ctx=Load()),
            slice=Constant(value=node.id),
            ctx=node.ctx
        )

Keep in mind that if the node you’re operating on has child nodes you must either transform the child nodes yourself or call the [`generic_visit()`](https://docs.python.org/3/library/ast.html#ast.NodeVisitor.generic_visit "ast.NodeVisitor.generic_visit") method for the node first.

For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.

If [`NodeTransformer`](https://docs.python.org/3/library/ast.html#ast.NodeTransformer "ast.NodeTransformer") introduces new nodes (that weren’t part of original tree) without giving them location information (such as [`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno")), [`fix_missing_locations()`](https://docs.python.org/3/library/ast.html#ast.fix_missing_locations "ast.fix_missing_locations") should be called with the new sub-tree to recalculate the location information:

tree = ast.parse('foo', mode='eval')
new_tree = fix_missing_locations(RewriteName().visit(tree))

Usually you use the transformer like this:

node = YourTransformer().visit(node)

ast.dump(_node_, _annotate\_fields=True_, _include\_attributes=False_, _*_, _indent=None_, _show\_empty=False_)[¶](https://docs.python.org/3/library/ast.html#ast.dump "Link to this definition")
Return a formatted dump of the tree in _node_. This is mainly useful for debugging purposes. If _annotate\_fields_ is true (by default), the returned string will show the names and the values for fields. If _annotate\_fields_ is false, the result string will be more compact by omitting unambiguous field names. Attributes such as line numbers and column offsets are not dumped by default. If this is wanted, _include\_attributes_ can be set to true.

If _indent_ is a non-negative integer or string, then the tree will be pretty-printed with that indent level. An indent level of 0, negative, or `""` will only insert newlines. `None` (the default) selects the single line representation. Using a positive integer indent indents that many spaces per level. If _indent_ is a string (such as `"\t"`), that string is used to indent each level.

If _show\_empty_ is false (the default), optional empty lists will be omitted from the output. Optional `None` values are always omitted.

Changed in version 3.9: Added the _indent_ option.

Changed in version 3.13: Added the _show\_empty_ option.

>>> print(ast.dump(ast.parse("""\
... async def f():
...  await other_func()
... """), indent=4, show_empty=True))
Module(
 body=[
 AsyncFunctionDef(
 name='f',
 args=arguments(
 posonlyargs=[],
 args=[],
 kwonlyargs=[],
 kw_defaults=[],
 defaults=[]),
 body=[
 Expr(
 value=Await(
 value=Call(
 func=Name(id='other_func', ctx=Load()),
 args=[],
 keywords=[])))],
 decorator_list=[],
 type_params=[])],
 type_ignores=[])

Compiler flags[¶](https://docs.python.org/3/library/ast.html#compiler-flags "Link to this heading")
---------------------------------------------------------------------------------------------------

The following flags may be passed to [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile") in order to change effects on the compilation of a program:

ast.PyCF_ALLOW_TOP_LEVEL_AWAIT[¶](https://docs.python.org/3/library/ast.html#ast.PyCF_ALLOW_TOP_LEVEL_AWAIT "Link to this definition")
Enables support for top-level `await`, `async for`, `async with` and async comprehensions.

Added in version 3.8.

ast.PyCF_ONLY_AST[¶](https://docs.python.org/3/library/ast.html#ast.PyCF_ONLY_AST "Link to this definition")
Generates and returns an abstract syntax tree instead of returning a compiled code object.

ast.PyCF_OPTIMIZED_AST[¶](https://docs.python.org/3/library/ast.html#ast.PyCF_OPTIMIZED_AST "Link to this definition")
The returned AST is optimized according to the _optimize_ argument in [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile") or [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse").

Added in version 3.13.

ast.PyCF_TYPE_COMMENTS[¶](https://docs.python.org/3/library/ast.html#ast.PyCF_TYPE_COMMENTS "Link to this definition")
Enables support for [**PEP 484**](https://peps.python.org/pep-0484/) and [**PEP 526**](https://peps.python.org/pep-0526/) style type comments (`# type: <type>`, `# type: ignore <stuff>`).

Added in version 3.8.

ast.compare(_a_, _b_, _/_, _*_, _compare\_attributes=False_)[¶](https://docs.python.org/3/library/ast.html#ast.compare "Link to this definition")
Recursively compares two ASTs.

_compare\_attributes_ affects whether AST attributes are considered in the comparison. If _compare\_attributes_ is `False` (default), then attributes are ignored. Otherwise they must all be equal. This option is useful to check whether the ASTs are structurally equal but differ in whitespace or similar details. Attributes include line numbers and column offsets.

Added in version 3.14.

Command-line usage[¶](https://docs.python.org/3/library/ast.html#command-line-usage "Link to this heading")
-----------------------------------------------------------------------------------------------------------

Added in version 3.9.

The [`ast`](https://docs.python.org/3/library/ast.html#module-ast "ast: Abstract Syntax Tree classes and manipulation.") module can be executed as a script from the command line. It is as simple as:

python -m ast [-m <mode>] [-a] [infile]

The following options are accepted:

-h,--help[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-h "Link to this definition")
Show the help message and exit.

-m<mode>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-m "Link to this definition")--mode<mode>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-mode "Link to this definition")
Specify what kind of code must be compiled, like the _mode_ argument in [`parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse").

--no-type-comments[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-no-type-comments "Link to this definition")
Don’t parse type comments.

-a,--include-attributes[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-a "Link to this definition")
Include attributes such as line numbers and column offsets.

-i<indent>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-i "Link to this definition")--indent<indent>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-indent "Link to this definition")
Indentation of nodes in AST (number of spaces).

--feature-version<version>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-feature-version "Link to this definition")
Python version in the format 3.x (for example, 3.10). Defaults to the current version of the interpreter.

Added in version 3.14.

-O<level>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-O "Link to this definition")--optimize<level>[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-optimize "Link to this definition")
Optimization level for parser. Defaults to no optimization.

Added in version 3.14.

--show-empty[¶](https://docs.python.org/3/library/ast.html#cmdoption-ast-show-empty "Link to this definition")
Show empty lists and fields that are `None`. Defaults to not showing empty objects.

Added in version 3.14.

If `infile` is specified its contents are parsed to AST and dumped to stdout. Otherwise, the content is read from stdin.

See also

[Green Tree Snakes](https://greentreesnakes.readthedocs.io/), an external documentation resource, has good details on working with Python ASTs.

[ASTTokens](https://asttokens.readthedocs.io/en/latest/user-guide.html) annotates Python ASTs with the positions of tokens and text in the source code that generated them. This is helpful for tools that make source code transformations.

[leoAst.py](https://leo-editor.github.io/leo-editor/appendices.html#leoast-py) unifies the token-based and parse-tree-based views of python programs by inserting two-way links between tokens and ast nodes.

[LibCST](https://libcst.readthedocs.io/) parses code as a Concrete Syntax Tree that looks like an ast tree and keeps all formatting details. It’s useful for building automated refactoring (codemod) applications and linters.

[Parso](https://parso.readthedocs.io/) is a Python parser that supports error recovery and round-trip parsing for different Python versions (in multiple Python versions). Parso is also able to list multiple syntax errors in your Python file.

### [Table of Contents](https://docs.python.org/3/contents.html)

*   [`ast` — Abstract syntax trees](https://docs.python.org/3/library/ast.html#)
    *   [Abstract grammar](https://docs.python.org/3/library/ast.html#abstract-grammar)
    *   [Node classes](https://docs.python.org/3/library/ast.html#node-classes)
        *   [Root nodes](https://docs.python.org/3/library/ast.html#root-nodes)
        *   [Literals](https://docs.python.org/3/library/ast.html#literals)
        *   [Variables](https://docs.python.org/3/library/ast.html#variables)
        *   [Expressions](https://docs.python.org/3/library/ast.html#expressions)
            *   [Subscripting](https://docs.python.org/3/library/ast.html#subscripting)
            *   [Comprehensions](https://docs.python.org/3/library/ast.html#comprehensions)

        *   [Statements](https://docs.python.org/3/library/ast.html#statements)
            *   [Imports](https://docs.python.org/3/library/ast.html#imports)

        *   [Control flow](https://docs.python.org/3/library/ast.html#control-flow)
        *   [Pattern matching](https://docs.python.org/3/library/ast.html#pattern-matching)
        *   [Type annotations](https://docs.python.org/3/library/ast.html#type-annotations)
        *   [Type parameters](https://docs.python.org/3/library/ast.html#type-parameters)
        *   [Function and class definitions](https://docs.python.org/3/library/ast.html#function-and-class-definitions)
        *   [Async and await](https://docs.python.org/3/library/ast.html#async-and-await)

    *   [`ast` helpers](https://docs.python.org/3/library/ast.html#ast-helpers)
    *   [Compiler flags](https://docs.python.org/3/library/ast.html#compiler-flags)
    *   [Command-line usage](https://docs.python.org/3/library/ast.html#command-line-usage)

#### Previous topic

[Python Language Services](https://docs.python.org/3/library/language.html "previous chapter")

#### Next topic

[`symtable` — Access to the compiler’s symbol tables](https://docs.python.org/3/library/symtable.html "next chapter")

### This page

*   [Report a bug](https://docs.python.org/3/bugs.html)
*   [Show source](https://github.com/python/cpython/blob/main/Doc/library/ast.rst?plain=1)

«

### Navigation

*   [index](https://docs.python.org/3/genindex.html "General Index")
*   [modules](https://docs.python.org/3/py-modindex.html "Python Module Index") |
*   [next](https://docs.python.org/3/library/symtable.html "symtable — Access to the compiler’s symbol tables") |
*   [previous](https://docs.python.org/3/library/language.html "Python Language Services") |
*   ![Image 3: Python logo](https://docs.python.org/3/_static/py.svg)
*   [Python](https://www.python.org/) »
*     

*   [3.14.2 Documentation](https://docs.python.org/3/index.html) » 
*   [The Python Standard Library](https://docs.python.org/3/library/index.html) »
*   [Python Language Services](https://docs.python.org/3/library/language.html) »
*   [`ast` — Abstract syntax trees](https://docs.python.org/3/library/ast.html)
*     | 
*    Theme   |

 © [Copyright](https://docs.python.org/3/copyright.html) 2001 Python Software Foundation. 

 This page is licensed under the Python Software Foundation License Version 2. 

 Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License. 

 See [History and License](https://docs.python.org/license.html) for more information.

 The Python Software Foundation is a non-profit corporation. [Please donate.](https://www.python.org/psf/donations/)

 Last updated on Jan 22, 2026 (15:56 UTC). [Found a bug](https://docs.python.org/bugs.html)? 

 Created using [Sphinx](https://www.sphinx-doc.org/) 8.2.3.
